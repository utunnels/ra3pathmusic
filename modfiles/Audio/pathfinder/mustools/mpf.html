<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>PathMusic Editor</title>
    <style>
    body, html {padding:0;; margin:0; display:table; width:100%;}
    #left {display:table-cell; padding:10px; box-sizing:border-box;}
    #right {display:table-cell; width:500px; padding:10px; box-sizing:border-box;}
    .msg {padding:5px 0;}
    </style>
  </head>
  <body>
    <div id="left">
      <div><input id="dumpbutton" type="button" value="Export files" onclick="dumpall()" /></div>
      <div class="msg" id="msg1">↑↑Warning: this will overwrite existing files</div>

      <div><input id="createbutton" type="button" value="Build new mus and mpf files" onclick="startthis()" /></div>
      <div class="msg" id="msg">↑↑Click this button to create new files for your mod</div>
    </div>
    <div id="right">
      <h3>Basic usage</h3>
      <p>1. Click "Export files", wait for it to complete.</p>
      <p>2. To replace a piece of music, convert your music file to wave format and put it in track.mus.files or track.mus.files or track-mem.mus.files. For example, 0.wav to replace 0.snr/sns, and so on.</p>
      <p>3. Run convert.bat, wait for it to complete.</p>
      <p>4. Click "Build new mus and mpf files", wait for it to complete.</p>
      <p>5. Build your mod using mod sdk and see/listen if it works.</p>
      <p>SDK settings: build global data</p>
      <h3>Advanced usage</h3>
      <p>You can edit events.txt, nodes.txt, and tracks.txt before "Build new mus and mpf files". You may also edit RA3Music.0.h in ra3music folder, if you want to add your own pathmusic event. However, since there are still many unknowns about mpf/mus format, this tool only makes sure you can modify the data, but can't grant the modification work.</p>
      <p>events.txt: The number used in eventID must match the last 6 numbers defined in RA3Music.0.h, for example, 0xf7413a matches 0x1f7413a. The number following # means track id. There can only be 255 events in this file, or the new mpf file will be corrupted.</p>
      <p>nodes.txt: The first part contains pathfinder nodes and branches, the second part (starts from [118,92]) contains routers. The routerID of a node matches router index +1, while 0 means no router specified. The index of a node matches file name +1 in track.directory or track-mem.directory, while 0 and -1 have special purposes.</p>
      <p>tracks.txt: Usually you only need to change startingsample of track-mem.mus, if you want to add new music files to track.mus, otherwise, leave this file alone.</p>
    </div>
    <script>
      function disablebuttons(){
        document.getElementById('dumpbutton').disabled='disabled';
        document.getElementById('createbutton').disabled='disabled';
      }
      function enablebuttons(){
        document.getElementById('dumpbutton').disabled='';
        document.getElementById('createbutton').disabled='';
      }
      function startthis(){
        document.getElementById('msg').innerHTML = 'Writing files...';
        disablebuttons();
        setTimeout(function(){
          writemusfiles();
          document.getElementById('msg').innerHTML = 'Done.';
          enablebuttons();
        },1);
      }
      function dumpall(){
        if(!confirm('Are your sure you want to export files?')){
          return;
        }
        var msg1 = document.getElementById('msg1');
        disablebuttons();
        msg1.innerHTML = 'Exporting files...';
        msg1.innerHTML += '<br>exporting snr and sns files from mus files...';
        setTimeout(function(){
          dumpsnrandsns();
        msg1.innerHTML += '<br>printing tracks.txt';
        setTimeout(function(){
          printtracks();
        msg1.innerHTML += '<br>printing nodes.txt';;
        setTimeout(function(){
          printnodeinfos();
        msg1.innerHTML += '<br>printing events.txt';
        setTimeout(function(){
          printevents();
          msg1.innerHTML += '<br>Done.';
          enablebuttons();
        },1);
        },1);
        },1);
        },1);
      }
    </script>
    <script src="somecrc32.js"></script>
    <script>
const fs = require('fs');

var path = '../';
var mpfpath = 'pc.mpf';
var musfiles = ['track.mus', 'track-mem.mus'];
var mpf = fs.readFileSync(path + mpfpath);

var pack = 1;

var PATHFINDHEADER ={
    id:-32,
    majorRev:8,
    minorRev: 8,
    release: 8,
    prerelease: 8,
    saveIncrement: 16,
    generateID: 16,
    projectID: 8,
    numtracks: 8,
    numsections: 8,
    numevents: 8,
    numrouters: 8,
    numnamedvars: 8,
    numnodes: 16,
    nodeoffsets: 32,
    nodedata: 32,
    eventoffsets: 32,
    eventdata: 32,
    namedvars: 32,
    noderouters: 32,
    trackoffsets: 32,
    trackinfos: 32,
    sampleoffsets: 32,
    mapfilelen: 32,
    v40reserve: [32,3],
};

var PATHNODEBEATS = {
    forcesynch : 1,
    playbeats : 1
};

var PATHNODEEVENT = {
    eventID : 24
};

var PATHNODECHANNEL = {
    eventID : 24,
    channelset : 4
};

var PATHNODEEXTRA = {
    beat: PATHNODEBEATS,
    sendevent: PATHNODEEVENT,
    channelbranch: PATHNODECHANNEL,
    __union: [32,1]
};

var PATHFINDNODE = {
    index : -16,
    trackID : 5,
    sectionID : 6,
    repeat : -5,
    routerID : 12,
    numbranches : 5,
    controller : 3,
    beats : 4,
    bars : 8,
    partID : 16,
    synchevery : 4,
    synchoffset : 4,
    notes : 4,
    synch : 2,
    channelbranching : 1,
    unused : 1,
    extra: PATHNODEEXTRA
};

var PATHEVENT = {
    queued: 32,
    expiry: 32,
    lastact: 32,
    eventID : 24,
    numactions : 8,
    currentaction : 8,
    voices : 4,
    priority : -4,
    bumplower : 1,
    beingFiltered : 1,
    project : -3,
    unused : -11
};

var PATHNAMEDVAR = {
    name: 'string(16)',
    value: -32
};

var PATHTRACKINFO = {
    startingsample: 32,
    numsubbanks: 16,
    purgemode: 16,
    muschecksum: 32,
    maxaram: 32,
    maxmram: 32
};

var PATHFINDSAMPLE = {
    offset: 32,
    duration: 32
};

var PATHMUSHEADER = {
    checksum: -32,
    numsamples: -32,
    reserved: [-8,32]
};

var PATHFINDBRANCH = {
    controlmin: -8,
    controlmax: -8,
    dstnode: 16
};

var PATHNODEOFFSETS = {
    nodechecksum: 32,
    index: 16,
    subindex: 16,
    snroffset: 32,
    snsoffset: 32,
    snrbytes: 32,
    snsbytes: 32,
    gstream: 32
};

const PATHACTIONTYPE = {
    PATHACTION_NONE : 0,
    PATHACTION_CONDITION : 1,
    PATHACTION_WAITTIME : 2,
    PATHACTION_WAITBEAT : 3,
    PATHACTION_BRANCHTO : 4,
    PATHACTION_FADE : 5,
    PATHACTION_DRYLEVELFADE : 6,
    PATHACTION_SFXFADE : 7,
    PATHACTION_SETVALUE : 8,
    PATHACTION_EVENT : 9,
    PATHACTION_FILTER_ON : 10,
    PATHACTION_FILTER_OFF : 11,
    PATHACTION_FILTER_CLEAR : 12,
    PATHACTION_CALLBACK : 13,
    PATHACTION_CALC : 14,
    PATHACTION_PAUSE : 15,
    PATHACTION_LOADBANK : 16,
    PATHACTION_PITCHFADE : 17,
    PATHACTION_STRETCHFADE : 18,
    PATHACTION_MAX : 19
};

const PATHFADETYPE = {
    PATH_FADE_LINEAR : 1,
    PATH_FADE_EQPOWER : 2,
    PATH_FADE_EXPONENTIAL : 3,
    PATH_FADE_COSINE : 4
};

var PATHACTPAUSE = {
    when : 16,
    on : 1
};

var PATHACTSTRETCHFADE = {
    tovol : 14,
    id : -3,
    flip : 1,
    ms : 14
};

var PATHACTCALC = {
    value : 8,
    op : 8,
    by : -16
};

const PATHVALUETYPE = {
    PATH_VALUE_BADTYPE : 0,
    PATH_VALUE_SPECIAL : 1,
    PATH_VALUE_VARIABLE : 2,
    PATH_VALUE_INTEGER : 3,
    PATH_VALUE_MAXTYPES : 4
};

const PATHSPECIALVALUETYPE = {
    PATH_SPECIALVALUE_BAD : 0,
    PATH_CONTROLLER : 1,
    PATH_CURRENTNODE : 2,
    PATH_CURRENTPART : 3,
    PATH_CURRENTSECTION : 4,
    PATH_EVENTEXPIRY : 5,
    PATH_EVENTPRIORITY : 6,
    PATH_FXBUS : 7,
    PATH_FXDRYLEVEL : 8,
    PATH_FXSENDLEVEL : 9,
    PATH_MAINVOICE : 10,
    PATH_NEXTNODE : 11,
    PATH_NOBRANCHING : 12,
    PATH_NODEDURATION : 13,
    PATH_PAUSE : 14,
    PATH_PITCHMULT : 15,
    PATH_PLAYINGNODE : 16,
    PATH_PLAYSTATUS : 17,
    PATH_RANDOMSHORT : 18,
    PATH_TIMENOW : 19,
    PATH_TIMETONEXTBEAT : 20,
    PATH_TIMETONEXTBAR : 21,
    PATH_TIMETONEXTNODE : 22,
    PATH_VOLUME : 23,
    PATH_TIMESTRETCH : 24,
    PATH_BARDURATION : 25,
    PATH_BEATDURATION : 26,
    PATH_CURRENTCHANNELSET : 27,
    PATH_PLAYINGCHANNELSET : 28,
    PATH_SPECIALVALUE_MAX : 29
};

const PATHOPERATOR = {
    PATH_OPERATOR_INVALID : 0,
    PATH_OPERATOR_ADD : 1,
    PATH_OPERATOR_SUB : 2,
    PATH_OPERATOR_MULT : 3,
    PATH_OPERATOR_DIV : 4,
    PATH_OPERATOR_MOD : 5,
    PATH_OPERATOR_MAX : 6
};

const PATHCOMPARE = {
    PATH_COMPARE_INVALID : 0,
    PATH_COMPARE_EQUALS : 1,
    PATH_COMPARE_NOT_EQUAL : 2,
    PATH_COMPARE_GREATER_THAN : 3,
    PATH_COMPARE_LESS_THAN : 4,
    PATH_COMPARE_GREATER_OR_EQUAL : 5,
    PATH_COMPARE_LESS_OR_EQUAL : 6,
    PATH_COMPARE_MAX : 7
};

var PATHACTCONDITION = {
    value : -16,
    compareValue : -16
};

var PATHACTCALLBACK = {
    value : -16,
    id : 16
};

var PATHACTFADE  = {
    tovol : 8,
    id : -7,
    flip : 1,
    ms : 16
};

var PATHACTSFXFADE = {
    tovol : 8,
    id : -7,
    flip : 1,
    ms : 16
};

var PATHACTSETVALUE = {
    towhat : -16,
    setwhat : 8
};

var PATHACTWAITTIME = {
    millisecs : -16,
    lowest : -16
};

var PATHACTPITCHFADE = {
    tovol : 14,
    id : -3,
    flip : 1,
    ms : 14
};

var PATHACTWAITBEAT = {
    millisecs : -16,
    every : 4,
    note : 4,
    offset : 4
};

var PATHACTDRYFADE = {
    tovol : 8,
    id : -7,
    flip : 1,
    ms : 16
};

var PATHACTEVENT = {
    eventid : 24
};

var PATHACTBRANCHTO = {
    node : -16,
    ofsection : -8,
    immediate : -1
};

var PATHLOADBANK = {
    subbanknum : 8,
    unload : 8
};

var PATHACT = {
    only: PATHACTCONDITION,
    waittime: PATHACTWAITTIME,
    waitbeat: PATHACTWAITBEAT,
    branch: PATHACTBRANCHTO,
    fade: PATHACTFADE,
    sfxfade: PATHACTSFXFADE,
    dryfade: PATHACTDRYFADE,
    pitchfade: PATHACTPITCHFADE,
    stretchfade: PATHACTSTRETCHFADE,
    setval: PATHACTSETVALUE,
    event: PATHACTEVENT,
    callback: PATHACTCALLBACK,
    calc: PATHACTCALC,
    pause: PATHACTPAUSE,
    loadbank: PATHLOADBANK,
    __union: [32,1]
};

var PATHACTION = {
    track: -32,
    sectionID : -8,
    type : 7,
    done : 1,
    leftvaluetype : 2,
    rightvaluetype : 2,
    assess : 3,
    comparison : 3,
    indent : 3,
    unused : 3,
    act: PATHACT
};

var MYSNRSTRUCT = {
    unimportant: 16,
    sampleratebe: 16,
    unk:8,
    numsamplesbe: 24
};

function vk(c,v){
  for(var k in c){
    if(c[k]==v){
      return k;
    }
  }
  return '';
}

function bitat(buf, pos){
  var sb1 = Math.floor(pos/8);
  var sb2 = pos%8;

  return (buf[sb1]&(1<<sb2))?1:0;
}

function getbitfield(buf, begin, length){
  length = length || 8;
  var v = 0;
  for(var i=0;i<length;i++){
    v|= bitat(buf, begin+i)<<i;
  }
  if(v<0) v += 0x100000000;
  return v; //for very long number, might have to use string instead
}

function setbitfield(buf, value, begin, length){
  for(var i=0;i<length;i++){
    var bit = (value&(1<<i))?1:0;
    var pos = begin+i;
    var sb1 = Math.floor(pos/8);
    var sb2 = pos%8;
    buf[sb1]&=~(bit<<sb2);
    buf[sb1]|=(bit<<sb2);
  }
}

function endian(n, bytes){
  bytes = bytes||4;
  var v = 0;
  for(var i=0;i<bytes;i++){
    var b = n&0xff;
    v |= b<< 8*(bytes-i-1);
    n>>=8;
  }
  return v;
}

function cleanupstruct(o){
  if(typeof(o)!='object'){
    return o;
  }
  if(o instanceof Array){
    for(var i=0;i<o.length;i++){
      o[i] = cleanupstruct(o[i]);
    }
    return o;
  }
  if(typeof(o.__value)!='undefined'){
    return cleanupstruct(o.__value);
  }else{
    for(var k in o){
      if(k=='__schema') continue;
      o[k] = cleanupstruct(o[k]);
    }
    return o;
  }
}

//TODO, check alignment
function unpack(schema, buf, begin){
  begin = begin||0;
  var offset = 0;
  var obj = {};
  if(typeof(schema)=='number') {
    obj.__value = getbitfield(buf, begin, Math.abs(schema));
    obj.__size = Math.abs(schema);
    if(schema<0){ //signed
      obj.__value <<= 32+schema;
      obj.__value >>= 32+schema;
    }
    return obj;
  }else if(schema=='float'){
      if((begin)%8!=0){
        throw new Exception("float number alignment error");
      }else{
        obj.__value=buf.readFloatLE((begin)/8);
        obj.__size=4*8;
        return obj;
      }
  }else if(schema=='int'){
    return unpack(-32, buf, begin);
  }else if(schema=='unsigned' || schema=='unsigned int'){
    return unpack(32, buf, begin);
  }else if(schema=='unsigned short'){
    return unpack(16, buf, begin);
  }else if(schema=='short'){
    return unpack(-16, buf, begin);
  }else if(schema=='unsigned char'){
    return unpack(8, buf, begin);
  }else if(schema=='char'){
    return unpack(-8, buf, begin);
  }else if(typeof(schema)=='string' && schema.indexOf('string(')==0){
    var l = parseInt(schema.substring(7));
    var s= buf.slice(begin/8, begin/8+l).toString().split('\0')[0];
    return {
      __value: s,
      __size:l*8
    };
  }else if(schema instanceof Array){
    var a = [];
    var sz = 0;
    for(var i=0;i<schema[1];i++){
      var o = unpack(schema[0], buf, begin+offset);
      a.push(o);
      offset += o.__size;
      sz += o.__size;
    }
    obj.__value = a;
    obj.__size = sz;
    return obj;
  }else if(typeof(schema)=='object'){
    if(schema.__union){
      var o = {};
      var v = unpack(schema.__union, buf, begin);
      offset += v.__size;
      o.__union = v;
      for(var k in schema){
        if(k.indexOf('__')!=0){
          var v = unpack(schema[k], buf, begin);
          o[k] = v;
        }
      }
      o.__size = o.__union.__size;
      cleanupstruct(o);
      o.__schema = schema;
      return o;
    }else{
      var o = {};
      var sz = 0;
      for(var k in schema){
        if(k.indexOf('__')!=0){
          var v = unpack(schema[k], buf, begin+offset);
          offset += v.__size;
          o[k] = v;
          sz += v.__size;
        }
      }
      o.__size = sz;
      cleanupstruct(o);
      o.__schema = schema;
      return o;
    }
  }else{
    //should ot be possible;
    throw new Exception("unknown schema: " + schema);
  }
}

var pos = 0;
var mpfheader = unpack(PATHFINDHEADER, mpf, 0);

pos  = mpfheader.nodeoffsets;
var mpfnodeoffsets = [];
for(var i=0;i<mpfheader.numnodes;i++,pos+=2){
  var no = mpf.readUInt16LE(pos);
  mpfnodeoffsets.push(no);
}
var mpfnodes = [];
var mpfbranches = [];
for(var i=0;i<mpfheader.numnodes;i++){
  pos = mpfnodeoffsets[i]*4; 
  var node = unpack(PATHFINDNODE, mpf, pos*8);
  mpfnodes.push(node);
  var branches = [];
  var bp = pos*8 + node.__size;
  for(var j=0;j<node.numbranches;j++){
    var br = unpack(PATHFINDBRANCH, mpf, bp);
    branches.push(br);
    bp+=br.__size;
  }
  mpfbranches.push(branches);
}

pos  = mpfheader.eventoffsets;
var mpfeventoffsets = [];
for(var i=0;i<mpfheader.numevents;i++,pos+=2){
  var ev = mpf.readUInt16LE(pos);
  mpfeventoffsets.push(ev);
}
var mpfevents = [];
var mpfactions = [];
for(var i=0;i<mpfheader.numevents;i++){
  pos = mpfeventoffsets[i]*4; 
  var event = unpack(PATHEVENT , mpf, pos*8);
  mpfevents.push(event);
  var actions = [];
  var ap = pos*8 + event.__size;
  for(var j=0;j<event.numactions;j++){
    var ac = unpack(PATHACTION , mpf, ap);
    actions.push(ac);
    ap+=ac.__size;
  }
  mpfactions.push(actions);
}

pos  = mpfheader.namedvars;
var mpfnamedvars = [];
var vp = 0;
for(var i=0;i<mpfheader.numnamedvars;i++){
  var nv = unpack(PATHNAMEDVAR , mpf, pos*8+vp);
  mpfnamedvars.push(nv);
  vp+=nv.__size;
}

pos  = mpfheader.noderouters;
var mpfnoderouters = [];
for(var i=0;i<mpfheader.numrouters+1;i++){
  var ro = mpf.readUInt32LE(pos+i*4);
  mpfnoderouters.push(ro);
}
var mpfrouters = [];
for(var i=0;i<mpfheader.numrouters;i++){
  pos = mpfnoderouters[i]*4; 
  var router = [];
  var count = (mpfnoderouters[i+1]-mpfnoderouters[i])*2;
  for(var j=0;j<count;j++){
    router.push(mpf.readUInt16LE(pos+j*2));
  }
  mpfrouters.push(router);
}

pos  = mpfheader.trackoffsets ;
var mpftrackoffsets = [];
for(var i=0;i<mpfheader.numtracks;i++,pos+=4){
  var tr = mpf.readUInt32LE(pos);
  mpftrackoffsets.push(tr);
}
var mpftrackinfos = [];
for(var i=0;i<mpfheader.numtracks;i++){
  pos = mpftrackoffsets[i]*4; 
  var trackinfo = unpack(PATHTRACKINFO , mpf, pos*8);
  mpftrackinfos.push(trackinfo);
}

pos  = mpfheader.sampleoffsets;
var mpfsamples = [];
var musheaders = []
var numsamples = 0;
//peek muf files 
for(var i=0;i<mpfheader.numtracks;i++){
  var musbuf = Buffer.alloc(128);
  var musf = fs.openSync(path + musfiles[i], 'r');
  fs.readSync(musf, musbuf, 0, musbuf.length);
  fs.closeSync(musf);
  var musheader = unpack(PATHMUSHEADER , musbuf, 0);
  musheaders.push(musheader);
  numsamples += musheader.numsamples;
}

//var numsamples = (mpfheader.mapfilelen - mpfheader.sampleoffsets)/8; //8 bytes struct
var sp = 0;
for(var i=0;i<numsamples;i++){
  var sample = unpack(PATHFINDSAMPLE , mpf, pos*8+sp);
  mpfsamples.push(sample);
  sp+=sample.__size;
}

var mpfobj = {};
var newmpfobj = {header:{}};
mpfobj.header = mpfheader;
mpfobj.nodeoffsets = mpfnodeoffsets;
mpfobj.nodes = mpfnodes;
mpfobj.branches = mpfbranches;
mpfobj.eventoffsets = mpfeventoffsets;
mpfobj.events = mpfevents;
mpfobj.actions = mpfactions;
mpfobj.namedvars = mpfnamedvars;
mpfobj.noderouters = mpfnoderouters;
mpfobj.routers = mpfrouters;
mpfobj.trackoffsets = mpftrackoffsets;
mpfobj.trackinfos = mpftrackinfos;
mpfobj.numsamples = numsamples;
mpfobj.samples = mpfsamples;

function dumpfile(inf, outf, begin, length){
  var tempbuf = Buffer.alloc(length);
  var infh = fs.openSync(inf, 'r');
  fs.readSync(infh, tempbuf, 0, length, begin);
  fs.closeSync(infh);
  var outfh = fs.openSync(outf, 'w');
  fs.writeSync(outfh, tempbuf, 0, length);
  fs.closeSync(outfh);
}

var muses = [];
for(var i=0;i<mpfheader.numtracks;i++){
  var musbuf = Buffer.alloc(musheaders[i].numsamples * (28 + 8) + musheaders[i].__size/8 + 128); //add 128 bytes just to be safe
  var muspath = path + musfiles[i];
  var musf = fs.openSync(muspath, 'r');
  fs.readSync(musf, musbuf, 0, musbuf.length);
  fs.closeSync(musf);
  var nodeoffsets = [];
  var snrinfos = [];
  var pos = 0;
  for(var j=0;j<musheaders[i].numsamples;j++){
    var mnode = unpack(PATHNODEOFFSETS , musbuf, musheaders[i].__size+pos);
    nodeoffsets.push(mnode);
    pos += mnode.__size;
    var snr = unpack(MYSNRSTRUCT , musbuf, mnode.snroffset*16*8);
    snr.__samplerate = endian(snr.sampleratebe,2);
    snr.__numsamples = endian(snr.numsamplesbe,3);
    snr.__duration = Math.floor(snr.__numsamples / snr.__samplerate * 1000);
    snrinfos.push(snr);
  }
  var musobj = {};
  musobj.header = musheaders[i];
  musobj.nodeoffsets = nodeoffsets;
  musobj.path = musfiles[i];
  musobj.snrinfos = snrinfos;
  muses.push(musobj);
}


//STUB
function pack(obj, buf, offset){
  var schema = obj.__schema;
  for(var k in schema){

  }
}

function rewritempfsamples(newpath){
  newpath = newpath || path + 'pc.0.mpf';
  var outfh = fs.openSync(newpath, 'w');
  fs.writeSync(outfh, mpf, 0, mpf.length);
  fs.closeSync(outfh);
}

function writemusfiles(){

  parsetracks();
  parsenodes();
  parseevents();
  //pc.mpf
  var newmpf = path + mpfpath.substring(0, mpfpath.length-4)+'.0.mpf';
  var newsamples = [];
  var startingsample = 0;
  for(var index=0;index<newmpfobj.header.numtracks;index++){
    //musobj as a template
    // currently, only the first mus (index=0) can be modified
    var musobj = muses[index]||muses[0];
    var oldpath = path + newmpfobj.trackinfos[index].path;
    var newpath = path + newmpfobj.trackinfos[index].path.substring(0, newmpfobj.trackinfos[index].path.length-4)+'.0.mus';
    /*
  var PATHMUSHEADER = {
      checksum: -32,
      numsamples: -32,
      reserved: [-8,32]
  };
    */
    var numsamples = 0;
    for(var i=0;;i++){
      try{fs.accessSync(oldpath + '.files/'+i+'.snr', fs.constants.F_OK);}catch(ex){
        numsamples = i;
        break;
      }
    }
    var outfh = fs.openSync(newpath, 'w');
    var offset = 0;
    var tempbuf = Buffer.alloc(musobj.header.__size/8);
    tempbuf.writeInt32LE(musobj.header.checksum, 0);
    tempbuf.writeInt32LE(numsamples, 4);
    for(var i=0;i<musobj.header.reserved.length;i++){
      tempbuf.writeInt8(musobj.header.reserved[i], 8+i);
    }
    fs.writeSync(outfh, tempbuf, 0, tempbuf.length, offset);
    offset += tempbuf.length;
    var snroffset = Math.ceil((offset + musobj.nodeoffsets[0].__size/8 * numsamples)/16);
    snroffset = Math.ceil(snroffset/16)*16;
    var snsoffset = Math.ceil((snroffset*16 + 16*numsamples)/128);
    tempbuf = Buffer.alloc(musobj.nodeoffsets[0].__size/8);
    newmpfobj.trackinfos[index].startingsample = startingsample;
    startingsample += numsamples;
    var filesize = 0;
    for(var i=0;i<numsamples;i++){
      /*
      nodechecksum: 32,
      index: 16,
      subindex: 16,
      snroffset: 32,
      snsoffset: 32,
      snrbytes: 32,
      snsbytes: 32,
      gstream: 32
      */
      var snr = fs.readFileSync(oldpath + '.files/' + i + '.snr');
      var sns = fs.readFileSync(oldpath + '.files/' + i + '.sns');
      var sample = {offset:snsoffset, duration:Math.floor((snr.readUInt32BE(4)-0x40000000)*1000/snr.readUInt16BE(2))};
      newsamples.push(sample);

      tempbuf.writeUInt32LE(crc32(sns), 0);
      tempbuf.writeUInt16LE(i, 4);
      tempbuf.writeUInt16LE(0, 6);
      tempbuf.writeUInt32LE(snroffset, 8);
      tempbuf.writeUInt32LE(snsoffset, 12);
      tempbuf.writeUInt32LE(snr.length, 16);
      tempbuf.writeUInt32LE(sns.length, 20);
      tempbuf.writeUInt32LE(0, 24);
      fs.writeSync(outfh, tempbuf, 0, tempbuf.length, offset);
      offset += tempbuf.length;
      fs.writeSync(outfh, snr, 0, snr.length, snroffset*16);
      fs.writeSync(outfh, sns, 0, sns.length, snsoffset*128);
      filesize = snsoffset*128 + sns.length;
      snroffset += Math.ceil(snr.length/16);
      snsoffset += Math.ceil(sns.length/128);
    }
    var expectedfilesize = snsoffset*128;
    if(filesize<expectedfilesize){
      tempbuf = Buffer.alloc(1);
      fs.writeSync(outfh, tempbuf, 0, 1, expectedfilesize-1);
    }//padding to 128 bytes

    fs.closeSync(outfh);
  }

  newmpfobj.samples = newsamples;

  /*
  header
  nodeoffsets
  nodes, branches 
  eventoffsets 
  events,actions
  namedvars
  noderouters 
  routers
  trackoffsets 
  trackinfos
  sampleoffsets 
  */
  //calc offsets
  newmpfobj.header.nodeoffsets = mpfobj.header.__size/8;
  var nodeoffset0 = newmpfobj.header.nodeoffsets + newmpfobj.header.numnodes*2;
  nodeoffset0 = Math.ceil(nodeoffset0/4);
  for(var i=0;i<newmpfobj.header.numnodes;i++){
    newmpfobj.nodeoffsets[i] += nodeoffset0;
    var nd = newmpfobj.nodes[i];
    if(nd.index>0){
      nd.index += newmpfobj.trackinfos[nd.trackID].startingsample;
    }
  }
  newmpfobj.header.nodedata = nodeoffset0*4;//_nodedatasize
  newmpfobj.header.eventoffsets = newmpfobj.header.nodedata + newmpfobj.header._nodedatasize;
  var eventoffset0 = newmpfobj.header.eventoffsets + newmpfobj.header.numevents*2;
  eventoffset0 = Math.ceil(eventoffset0/4);
  for(var i=0;i<newmpfobj.header.numevents;i++){
    newmpfobj.eventoffsets[i] += eventoffset0;
  }
  newmpfobj.header.eventdata = eventoffset0*4;//_eventdatasize
  newmpfobj.header.namedvars = newmpfobj.header.eventdata + newmpfobj.header._eventdatasize;
  newmpfobj.header.noderouters = newmpfobj.header.namedvars + mpfobj.namedvars[0].__size/8*newmpfobj.header.numnamedvars;
  var routeroffset0 = newmpfobj.header.noderouters + newmpfobj.header.numrouters*4+4;
  routeroffset0 = Math.ceil(routeroffset0/4);
  for(var i=0;i<newmpfobj.header.numrouters+1;i++){
    newmpfobj.noderouters[i] += routeroffset0;
  }
  newmpfobj.header.trackoffsets = newmpfobj.noderouters[newmpfobj.header.numrouters]*4;
  var trackoffset0 = newmpfobj.header.trackoffsets + newmpfobj.header.numtracks*4;
  trackoffset0 = Math.ceil(trackoffset0/4);
  for(var i=0;i<newmpfobj.header.numtracks;i++){
    newmpfobj.trackoffsets[i] += trackoffset0;
  }
  newmpfobj.header.trackinfos = trackoffset0*4;
  newmpfobj.header.sampleoffsets = newmpfobj.header.trackinfos + mpfobj.trackinfos[0].__size/8*newmpfobj.header.numtracks;
  newmpfobj.header.mapfilelen = newmpfobj.header.sampleoffsets + mpfobj.samples[0].__size/8 * newsamples.length;
  
  outfh = fs.openSync(newmpf, 'w');
  var pos = 0;
  var offset = 0;
  var newheader = newmpfobj.header, oldheader = mpfobj.header;
  var tempb = Buffer.alloc(oldheader.__size/8);
  function _wb(_old, _new, k,l){
    var v = _new[k]==undefined?_old[k] : _new[k];
    setbitfield(tempb, v, pos, l);pos+=l;
  }
  function _wb1(k,l){
    _wb(oldheader,newheader, k,l);
  }
  _wb1('id',32);
  _wb1('majorRev',8);
  _wb1('minorRev',8);
  _wb1('release',8);
  _wb1('prerelease',8);
  _wb1('saveIncrement',16);
  _wb1('generateID',16);
  _wb1('projectID',8);
  _wb1('numtracks',8);
  _wb1('numsections',8);
  _wb1('numevents',8);
  _wb1('numrouters',8);
  _wb1('numnamedvars',8);
  _wb1('numnodes',16);
  _wb1('nodeoffsets',32);
  _wb1('nodedata',32);
  _wb1('eventoffsets',32);
  _wb1('eventdata',32);
  _wb1('namedvars',32);
  _wb1('noderouters',32);
  _wb1('trackoffsets',32);
  _wb1('trackinfos',32);
  _wb1('sampleoffsets',32);
  _wb1('mapfilelen',32);
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);
  
  offset = newheader.nodeoffsets;
  tempb = Buffer.alloc(newheader.numnodes*2);
  for(var i=0;i<newheader.numnodes;i++){
    tempb.writeUInt16LE(newmpfobj.nodeoffsets[i], i*2);
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.nodedata;
  for(var i=0;i<newheader.numnodes;i++){
    var newnode = newmpfobj.nodes[i];
    var v,l;
    pos=0;
/*
    int index : 16;
    unsigned int trackID : 5;
    unsigned int sectionID : 6;
    int repeat : 5;
    unsigned int routerID : 12;
    unsigned int numbranches : 5;
    unsigned int controller : 3;
    unsigned int beats : 4;
    unsigned int bars : 8;
    unsigned int partID : 16;
    unsigned int synchevery : 4;
    unsigned int synchoffset : 4;
    unsigned int notes : 4;
    unsigned int synch : 2;
    unsigned int channelbranching : 1;
    unsigned int unused : 1;
    PATHNODEEXTRA extra;
*/
    tempb = Buffer.alloc(mpfobj.nodes[0].__size/8);
    v = newnode.index||0;l=16;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.trackID||0;l=5;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.sectionID||0;l=6;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.repeat||0;l=5;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.routerID||0;l=12;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.numbranches||0;l=5;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.controller||0;l=3;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.beats||0;l=4;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.bars||0;l=8;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.partID||0;l=16;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.synchevery||0;l=4;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.synchoffset||0;l=4;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.notes||0;l=4;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.synch||0;l=2;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = newnode.channelbranching||0;l=1;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = 0;l=1; //unused
    setbitfield(tempb, v, pos, l);pos+=l;
    v = 0;l=32; //extra
    setbitfield(tempb, v, pos, l);pos+=l;
    fs.writeSync(outfh, tempb, 0, tempb.length, offset);
    offset += tempb.length;
    for(var j=0;j<newnode.numbranches;j++){
      tempb = Buffer.alloc(mpfobj.branches[0][0].__size/8);
      var br = newmpfobj.branches[i][j];
      pos = 0;
      v = br.controlmin||0;l=8;
      setbitfield(tempb, v, pos, l);pos+=l;
      v = br.controlmax||0;l=8;
      setbitfield(tempb, v, pos, l);pos+=l;
      v = br.dstnode||0;l=16;
      setbitfield(tempb, v, pos, l);pos+=l;
      fs.writeSync(outfh, tempb, 0, tempb.length, offset);
      offset += tempb.length;
    }
  }

  offset = newheader.eventoffsets;
  tempb = Buffer.alloc(newheader.numevents*2);
  for(var i=0;i<newheader.numevents;i++){
    tempb.writeUInt16LE(newmpfobj.eventoffsets[i], i*2);
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.eventdata;
  tempb = Buffer.alloc(newheader._eventdatasize);
  events = newmpfobj.events;
  pos = 0;
  for(var i=0;i<events.length;i++){
    var v;
    //event
    v = events[i].queued||0;
    setbitfield(tempb, v, pos, 32);pos+=32;
    v = events[i].expiry||0;
    setbitfield(tempb, v, pos, 32);pos+=32;
    v = events[i].lastact||0;
    setbitfield(tempb, v, pos, 32);pos+=32;
    v = events[i].eventID||0;
    setbitfield(tempb, v, pos, 24);pos+=24;
    v = events[i].numactions||0;
    setbitfield(tempb, v, pos, 8);pos+=8;
    v = events[i].currentaction||0;
    setbitfield(tempb, v, pos, 8);pos+=8;
    v = events[i].voices||0;
    setbitfield(tempb, v, pos, 4);pos+=4;
    v = events[i].priority||0;
    setbitfield(tempb, v, pos, 4);pos+=4;
    v = events[i].bumplower||0;
    setbitfield(tempb, v, pos, 1);pos+=1;
    v = events[i].beingFiltered||0;
    setbitfield(tempb, v, pos, 1);pos+=1;
    v = events[i].project||0;
    setbitfield(tempb, v, pos, 3);pos+=3;
    v = events[i].unused||0;
    setbitfield(tempb, v, pos, 11);pos+=11;
    //actions
    for(var j=0;j<events[i].numactions;j++){
      v = events[i].actions[j].track||0;
      setbitfield(tempb, v, pos, 32);pos+=32;
      v = events[i].actions[j].sectionID||0;
      setbitfield(tempb, v, pos, 8);pos+=8;
      v = events[i].actions[j].type||0;
      setbitfield(tempb, v, pos, 7);pos+=7;
      v = events[i].actions[j].done||0;
      setbitfield(tempb, v, pos, 1);pos+=1;
      v = events[i].actions[j].leftvaluetype||0;
      setbitfield(tempb, v, pos, 2);pos+=2;
      v = events[i].actions[j].rightvaluetype||0;
      setbitfield(tempb, v, pos, 2);pos+=2;
      v = events[i].actions[j].assess||0;
      setbitfield(tempb, v, pos, 3);pos+=3;
      v = events[i].actions[j].comparison||0;
      setbitfield(tempb, v, pos, 3);pos+=3;
      v = events[i].actions[j].indent||0;
      setbitfield(tempb, v, pos, 3);pos+=3;
      v = events[i].actions[j].unused||0;
      setbitfield(tempb, v, pos, 3);pos+=3;
      //act union
      var oldpos = pos; //for the union 
      if(events[i].actions[j].act.setval){
        v = events[i].actions[j].act.setval.towhat||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
        v = events[i].actions[j].act.setval.setwhat||0;
        setbitfield(tempb, v, pos, 8);pos+=8;
      }else if(events[i].actions[j].act.calc){
        v = events[i].actions[j].act.calc.value||0;
        setbitfield(tempb, v, pos, 8);pos+=8;
        v = events[i].actions[j].act.calc.op||0;
        setbitfield(tempb, v, pos, 8);pos+=8;
        v = events[i].actions[j].act.calc.by||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
      }else if(events[i].actions[j].act.only){
        v = events[i].actions[j].act.only.value||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
        v = events[i].actions[j].act.only.compareValue||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
      }else if(events[i].actions[j].act.event){
        v = events[i].actions[j].act.event.eventid||0;
        setbitfield(tempb, v, pos, 24);pos+=24;
      }else if(events[i].actions[j].act.waittime){
        v = events[i].actions[j].act.waittime.millisecs||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
        v = events[i].actions[j].act.waittime.lowest||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
      }else if(events[i].actions[j].act.fade){
        v = events[i].actions[j].act.fade.tovol||0;
        setbitfield(tempb, v, pos, 8);pos+=8;
        v = events[i].actions[j].act.fade.id||0;
        setbitfield(tempb, v, pos, 7);pos+=7;
        v = events[i].actions[j].act.fade.flip||0;
        setbitfield(tempb, v, pos, 1);pos+=1;
        v = events[i].actions[j].act.fade.ms||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
      }else if(events[i].actions[j].act.branch){
        v = events[i].actions[j].act.branch.node||0;
        setbitfield(tempb, v, pos, 16);pos+=16;
        v = events[i].actions[j].act.branch.ofsection||0;
        setbitfield(tempb, v, pos, 8);pos+=8;
        v = events[i].actions[j].act.branch.immediate||0;
        setbitfield(tempb, v, pos, 1);pos+=1;
      }
      pos = oldpos+32;
    }
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.namedvars;
  for(var i=0;i<newheader.numnamedvars;i++){
    tempb = Buffer.alloc(mpfobj.namedvars[0].__size/8);
    var va = newmpfobj.namedvars[i];
    tempb.asciiWrite(va.name);
    tempb.writeInt32LE(va.value, 16);
    fs.writeSync(outfh, tempb, 0, tempb.length, offset);
    offset += tempb.length;
  }

  offset = newheader.noderouters;
  tempb = Buffer.alloc(newheader.numrouters*4+4);
  for(var i=0;i<newheader.numrouters+1;i++){
    tempb.writeUInt32LE(newmpfobj.noderouters[i], i*4);
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newmpfobj.noderouters[0]*4;
  tempb = Buffer.alloc(newmpfobj.noderouters[newheader.numrouters]*4 - offset);
  pos = 0;
  for(var i=0;i<newheader.numrouters;i++){
    var r = newmpfobj.routers[i];
    for(var j=0;j<r.length;j++){
      tempb.writeUInt16LE(r[j], pos);
      pos += 2;
    }
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.trackoffsets;
  tempb = Buffer.alloc(newheader.numtracks*4);
  for(var i=0;i<newheader.numtracks;i++){
    tempb.writeUInt32LE(newmpfobj.trackoffsets[i], i*4);
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.trackinfos;
  tempb = Buffer.alloc(mpfobj.trackinfos[0].__size*newheader.numtracks/8);
  pos = 0;
  for(var i=0;i<newheader.numtracks;i++){
    var v,l;
    var tr = newmpfobj.trackinfos[i];
    v = tr.startingsample||0;l=32;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = tr.numsubbanks||0;l=16;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = tr.purgemode||0;l=16;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = tr.muschecksum||0;l=32;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = tr.maxaram||0;l=32;
    setbitfield(tempb, v, pos, l);pos+=l;
    v = tr.maxmram||0;l=32;
    setbitfield(tempb, v, pos, l);pos+=l;
  }
  fs.writeSync(outfh, tempb, 0, tempb.length, offset);

  offset = newheader.sampleoffsets;
  tempbuf = Buffer.alloc(8);
  for(var i=0;i<newsamples.length;i++){
    tempbuf.writeUInt32LE(newsamples[i].offset);
    tempbuf.writeUInt32LE(newsamples[i].duration,4);
    fs.writeSync(outfh, tempbuf, 0, 8, offset + tempbuf.length*i);
  }
  fs.closeSync(outfh);

}

function dumpsnrandsns(){
  for(var i=0;i<mpfheader.numtracks;i++){
    var dumpdir = path + muses[i].path+'.files';
    try{
      fs.mkdirSync(dumpdir);
    }catch(ex){}
    for(var j=0;j<muses[i].header.numsamples;j++){
      var info = muses[i].nodeoffsets[j];
      dumpfile(path + muses[i].path, dumpdir + '/'+j+'.snr', info.snroffset*16, info.snrbytes);
      dumpfile(path + muses[i].path, dumpdir + '/'+j+'.sns', info.snsoffset*128, info.snsbytes);
    }
  }
}

function printtracks(){
  var ss = '';
  ss += '[\n';
  for(var i=0;i<mpfobj.header.numtracks;i++){
    var tr = mpfobj.trackinfos[i];
    ss += '\t{ path: "' +muses[i].path+ '", startingsample: ' + tr.startingsample + ', numsubbanks: ' + tr.numsubbanks + ', purgemode: ' + tr.purgemode + ', muschecksum: '+ tr.muschecksum + ', maxaram: ' + tr.maxaram + ', maxmram: ' + tr.maxmram + '},\n';
  }
  ss += ']\n';
  fs.writeFileSync(path + 'tracks.txt', ss, 'utf-8');
}

function printevents(){
  var str = fs.readFileSync(path + 'ra3music/pc/ra3music.h','utf-8');//or should it be ansi??
  var lines = str.split(/[\r\n]+/g);
  var ss = '';
  for(var i=0;i<lines.length;i++){
    lines[i] = lines[i].split(/[\s\t]+/g);
  }
  function findevent(num){
    for(var i=0;i<lines.length;i++){
      if(lines[i].length>=3 && eval(lines[i][2])==num){
        return lines[i][1];
      }
    }
    return '';
  }
  function op(o){
    var operators = [' invalid_op_0 ', '+=', '-=', '*=', '/=', '%=', ' invalid_op_6 '];
    return operators[o];
  }
  function cmp(o){
    var operators = [' invalid_op_0 ', '==', '!=', '>', '<', '>=', '<=', ' invalid_op_7 '];
    return operators[o];
  }
  function val(v){
    if(v<mpfobj.namedvars.length){
      return 'vars[\''+ mpfobj.namedvars[v].name + '\']';
    }else {
      return 'vars['+v+']';
    }
  }
  function parseactionstring(a){
    var s = '';
    if(a.type==PATHACTIONTYPE.PATHACTION_SETVALUE){
      if(a.leftvaluetype==PATHVALUETYPE.PATH_VALUE_VARIABLE){
        s += val(a.act.setval.setwhat) + '=';
      }else if(a.leftvaluetype==PATHVALUETYPE.PATH_VALUE_SPECIAL){
        s += vk(PATHSPECIALVALUETYPE, a.act.setval.setwhat) + '=';
      }else {
        s += 'unknown_leftvaluetype_' + a.leftvaluetype + "=";
      }
      if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_INTEGER){
        s += a.act.setval.towhat;
      }else if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_SPECIAL){
        s += vk(PATHSPECIALVALUETYPE, a.act.setval.towhat);
      }else {
        s += 'unknown_rightvaluetype_' + a.rightvaluetype;
      }
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_CALC){
      if(a.leftvaluetype==PATHVALUETYPE.PATH_VALUE_VARIABLE){
        s += val(a.act.calc.value);
      }else{
        s += 'unknown_leftvaluetype_' + a.leftvaluetype;
      }
      s += op(a.act.calc.op);
      if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_INTEGER){
        s += a.act.calc.by;
      }else{
        s += 'unknown_rightvaluetype_' + a.rightvaluetype;
      }
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_EVENT){
      s += 'call(' + findevent(a.act.event.eventid|0x1000000) + '_0x' + a.act.event.eventid.toString(16) + ')';
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_WAITTIME){
      s += 'wait('
      if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_INTEGER){
        s += 'lowest=' + a.act.waittime.lowest + ', millisecs=' + a.act.waittime.millisecs;
      }else if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_SPECIAL){
        s += 'lowest=' + a.act.waittime.lowest + ', millisecs=' + vk(PATHSPECIALVALUETYPE, a.act.waittime.millisecs);
      }else{
        s += 'unknown_rightvaluetype_' + a.rightvaluetype;
      }
      s+=')';
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_FADE ){
      s += 'fade('
      if(a.rightvaluetype==PATHVALUETYPE.PATH_VALUE_INTEGER){
        s += 'tovol=' + a.act.fade.tovol + ', id=' + vk(PATHFADETYPE,a.act.fade.id) + ', flip=' + a.act.fade.flip + ', ms=' + a.act.fade.ms;
      }else{
        s += 'unknown_rightvaluetype_' + a.rightvaluetype;
      }
      s += ')';
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_CONDITION){
      if(a.assess==1){
        s+='if(';
      }else if(a.assess==2){
        s+='else if(';
      }else if(a.assess==3){
        s+='else'
      }else if(a.assess==4){
        s+='end if'
      }
      if(a.assess==1||a.assess==2){
        s += val(a.act.only.value);
        s += cmp(a.comparison);
        s += a.act.only.compareValue;
        s += ')'
      }
      return s;
    }else if(a.type==PATHACTIONTYPE.PATHACTION_BRANCHTO){
      s += 'branchto(';
      s += 'node=' + a.act.branch.node + ', ofsection=' + a.act.branch.ofsection + ', immediate=' + (a.act.branch.immediate?'true':'false');
      s += ')';
      return s;
    }
    return 'unknow action: ' + a.type;
  }

  function trackname(t){
    if(t==0x11000001) return ' #0';
    if(t==0x11000002) return ' #1';
    return '';
  }

  ss += "vars: {\n";
  for(var i=0;i<mpfobj.namedvars.length;i++){
    ss += '\t' + mpfobj.namedvars[i].name + ': ' + mpfobj.namedvars[i].value + ',\n'; 
  }
  ss +="},\n"

  for(var i=0;i<mpfobj.events.length;i++){
    //console.log(findevent(mpfobj.events[i].eventID), mpfobj.events[i].eventID.toString('16'));
    ss += "event: {\n\teventID: " + findevent(mpfobj.events[i].eventID|0x1000000) + "_0x" + mpfobj.events[i].eventID.toString(16) + ',\n';
    ss += "\tactions:[\n";
    for(var j=0;j<mpfobj.actions[i].length;j++){
      //ss += "\t\t{\n\t\ttrack: " + findevent(mpfobj.actions[i][j].track) + ",\n";
      ss += "\t\t" + parseactionstring(mpfobj.actions[i][j]) + trackname(mpfobj.actions[i][j].track) +"\n";
      //ss += "\t\t},\n";
    }
    ss += "\t],\n";
    ss += "},\n";
  }

  fs.writeFileSync(path + 'events.txt', ss, 'utf-8');
}

function printnodeinfos(){
  var ss = '';
  for(var i=0;i<mpfobj.nodes.length;i++){
    //node
    var nd = mpfobj.nodes[i];
    ss += '{index: ' + (nd.index>0?(nd.index-mpfobj.trackinfos[nd.trackID].startingsample):nd.index);
    ss += ', trackID: ' + nd.trackID;
    ss += ', sectionID: ' + nd.sectionID;
    ss += ', repeat: ' + nd.repeat;
    ss += ', routerID: ' + nd.routerID;
    ss += ', numbranches: ' + nd.numbranches;
    //ss += ', controller: ' + nd.controller;
    ss += ', beats: ' + nd.beats;
    ss += ', bars: ' + nd.bars;
    ss += ', partID: ' + nd.partID;
    //ss += ', synchevery: ' + nd.synchevery;
    //ss += ', synchoffset: ' + nd.synchoffset;
    ss += ', notes: ' + nd.notes;
    //ss += ', synch: ' + nd.synch;
    //ss += ', channelbranching: ' + nd.channelbranching;
    ss += '}, //'+i+'\n';
    //branches
    for(var j=0;j<nd.numbranches;j++){
      var br = mpfobj.branches[i][j];
      ss += '\t{controlmin: ' + br.controlmin;
      ss += ', controlmax: ' + br.controlmax;
      ss += ', dstnode: ' + br.dstnode;
      ss += '},\n';
    }
  }
  for(var i=0;i<mpfobj.routers.length;i++){
    var rt = mpfobj.routers[i];
    ss += '[' +rt + '], //'+i+'\n';
  }
  ss = '[\n' + ss + ']\n';
  fs.writeFileSync(path + 'nodes.txt', ss, 'utf-8');
}

function parsetracks(){
  var text = fs.readFileSync(path + 'tracks.txt', 'utf-8');
  var objs = eval(text);
  var trackoffsets = [];
  newmpfobj.trackinfos = [];
  var offset = 0;
  for(var i=0;i<objs.length;i++){
    if(objs[i]){
      newmpfobj.trackinfos.push(objs[i]);
      trackoffsets.push(offset);
      offset += mpfobj.trackinfos[0].__size/8/4;
    }
  }
  newmpfobj.header.numtracks = trackoffsets.length;
  newmpfobj.trackoffsets = trackoffsets;
}

function parsenodes(){
  var text = fs.readFileSync(path + 'nodes.txt', 'utf-8');
  var nodesize=mpfobj.nodes[0].__size/8;
  var branchsize=mpfobj.branches[0][0].__size/8;
  var objs = eval(text);
  var nodeoffsets = [];
  var nodes = [];
  var branches = [];
  var routers = [];
  var noderouters = [];
  var offset = 0;
  var routeroffset = 0;
  for(var i=0;i<objs.length;i++){
    var o = objs[i];
    if(typeof(o)=='object' && typeof(o.index)!='undefined'){ // this is a node
      nodes.push(o);
      branches.push([]);
      nodeoffsets.push(Math.round(offset));
      offset += nodesize/4;
    }else if(typeof(o)=='object' && typeof(o.dstnode)!='undefined'){ // this is a branch
      branches[branches.length-1].push(o);
      offset += branchsize/4;
    }else if(o instanceof Array){ //this is a router
      routers.push(o);
      noderouters.push(routeroffset);
      routeroffset += o.length*2/4;
    }
  }
  noderouters.push(routeroffset); 
  newmpfobj.nodes = nodes;
  newmpfobj.branches = branches;
  newmpfobj.noderouters = noderouters;
  newmpfobj.routers = routers
  newmpfobj.nodeoffsets = nodeoffsets;
  newmpfobj.header.numnodes = nodes.length;
  newmpfobj.header.numrouters = routers.length;
  newmpfobj.header._nodedatasize = offset*4;
}

function parseevents(){
  var namedvars = [];
  var events = [];
  var actions = [];
  var eventoffsets = [];
  var eventoffset = 0;
  var currentevent;
  var ac = 0;
  var eventsize = mpfobj.events[0].__size/8; //16
  var actionsize = mpfobj.actions[0][0].__size/8; //12
  var text = fs.readFileSync(path + 'events.txt', 'utf-8');
  var lines = text.split(/[\r\n]+/g);
  var varbegin = false, eventbegin = false, varset = false, actionbegin=false;
  function eid(str){
    var m = str.match(/\w*_(0x[0-9a-f]+)/i);
    if(m){
      return eval(m[1]);
    }
    return -1;
  }
  function gettrack(t){
    if(typeof(t)=='undefined') return -1;
    t = parseInt(t);
    if(t==0){
      return 0x11000001;
    }else if(t==1){
      return 0x11000002;
    }else if(t==-1){
      return -1;
    }else{
      return t;//new track?
    }
  }
  function vi(n){
    if(n.charAt(0)=='"'||n.charAt(0)=="'"){
      n = n.substring(1,n.length-1);
      var i=0;
      for(var i=0;i<namedvars.length;i++){
        if(namedvars[i].name==n){
          return i;
        }
      }
      throw new Error('named variable '+n+' not found');
    }else{
      return parseInt(n);
    }
  }
  function opi(o){
    var ops = {
    '+=':1,
    '-=':2,
    '*=':3,
    '/=':4,
    '%=':5
    };
    return ops[o];
  }
  function cmpi(o){
    var ops = {
    '==':1,
    '!=':2,
    '>':3,
    '<':4,
    '>=':5,
    '<=':6
    };
    return ops[o];
  }
  function isnum(o){
    return !!o.match(/^-?[0-9]/);
  }
  function parseaction(astr){
    var m;
    var action = {act:{}};
    action.astr=astr;
    if(m=astr.match(/^\s*vars\s*\[\s*([^\s]+)\s*\]\s*=\s*(-?\w+)\s*(#\s*(-?\w+)\s*)?/i)) { //vars['player']=1 #0
      action.track = gettrack(m[4]);
      action.type = PATHACTIONTYPE.PATHACTION_SETVALUE;
      action.act.setval={};
      action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_VARIABLE;
      action.act.setval.setwhat = vi(m[1]);
      if(!isnum(m[2])){
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_SPECIAL;
        action.act.setval.towhat = PATHSPECIALVALUETYPE[m[2]];
      }else{
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
        action.act.setval.towhat = parseInt(m[2]);
      }
    }else if(m=astr.match(/^\s*(\w+)\s*=\s*(-?\w+)\s*(#\s*(-?\w+)\s*)?/i)){ //PATH_VOLUME=100
      action.track = gettrack(m[4]);
      action.type = PATHACTIONTYPE.PATHACTION_SETVALUE;
      action.act.setval={};
      action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_SPECIAL;
      action.act.setval.setwhat = PATHSPECIALVALUETYPE[m[1]];
      if(!isnum(m[2])){
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_SPECIAL;
        action.act.setval.towhat = PATHSPECIALVALUETYPE[m[2]];
      }else{
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
        action.act.setval.towhat = parseInt(m[2]);
      }
    }else if(m=astr.match(/^\s*vars\s*\[\s*([^\s]+)\s*\]\s*([\%\+\-\*\/]=)\s*(-?\w+)\s*(#\s*(-?\w+)\s*)?/i)){ //vars['shelltrack']+=1 #0
      action.track = gettrack(m[5]);
      action.type = PATHACTIONTYPE.PATHACTION_CALC;
      action.act.calc={};
      action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_VARIABLE;
      action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
      action.act.calc.value = vi(m[1]);
      action.act.calc.op = opi(m[2]);
      action.act.calc.by = parseInt(m[3]);
    }else if(m=astr.match(/^\s*(((else|end)\s+)?if\s*(\(\s*vars\s*\[\s*([^\s]+)\s*\]\s*(==|!=|>=|<|>)\s*(-?\w+)\))?|else)\s*(#\s*(-?\w+)\s*)?/i)){ // if
      action.track = gettrack(m[9]);
      action.type = PATHACTIONTYPE.PATHACTION_CONDITION;
      action.act.only={};
      if(m[1]=='else'){
        action.assess=3;
      }else if(m[3]=='end'){
        action.assess=4;
      }else if(m[3]=='else'){
        action.assess=2;
      }else{
        action.assess=1;
      }
      if(action.assess<=2){
        action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_VARIABLE;
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
        action.comparison = cmpi(m[6]);
        action.act.only.value = vi(m[5]);
        action.act.only.compareValue = parseInt(m[7]);
      }else{
        action.leftvaluetype = 0;
        action.rightvaluetype = 0;
        action.comparison = 0;
        action.act.only.value = 0;
        action.act.only.compareValue = 0;
      }
    }else if(m=astr.match(/^\s*call\s*\(\s*(\w+)?_([0-9]\w*)\s*\)\s*(#\s*(-?\w+)\s*)?/i)){ //call(PATH_EVENT_S_S02KrasnaSickle1_0xb36e60) #0
      //not used in ra3
      action.track = gettrack(m[4]);
      action.type = PATHACTIONTYPE.PATHACTION_EVENT;
      action.act.event={};
      action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
      action.rightvaluetype = 0;
      action.act.event.eventid = parseInt(m[3]);
    }else if(m=astr.match(/^\s*wait\s*\(\s*(lowest\s*=)?\s*(-?\w+)\s*,\s*(millisecs\s*=)?\s*(-?\w+)\s*\)\s*(#\s*(-?\w+)\s*)?/i)){ //wait(lowest=0, millisecs=1002) #0
      action.track = gettrack(m[6]);
      action.type = PATHACTIONTYPE.PATHACTION_WAITTIME;
      action.act.waittime={};
      action.leftvaluetype = 0;
      action.act.waittime.lowest = parseInt(m[2]);
      if(isnum(m[4])){
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
        action.act.waittime.millisecs=parseInt(m[4]);
      }else{
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_SPECIAL;
        action.act.waittime.millisecs=PATHSPECIALVALUETYPE[m[4]];
      }
    }else if(m=astr.match(/^\s*fade\s*\(\s*(tovol\s*=)?\s*(-?\w+)\s*,\s*(id\s*=)?\s*(-?\w+)\s*,\s*(flip\s*=)?\s*(-?\w+)\s*,\s*(ms\s*=)?\s*(-?\w+)\s*\)\s*(#\s*(-?\w+)\s*)?/i)){ //fade(tovol=0, id=PATH_FADE_LINEAR, flip=0, ms=1000) #0
      action.track = gettrack(m[10]);
      action.type = PATHACTIONTYPE.PATHACTION_FADE;
      action.act.fade={};
      action.leftvaluetype = 0;
      action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
      action.act.fade.tovol = parseInt(m[2]);
      action.act.fade.id = PATHFADETYPE[m[4]];
      action.act.fade.flip = eval(m[6])?'-1':'0';
      action.act.fade.ms = parseInt(m[8]);
    }else if(m=astr.match(/^\s*branchto\s*\(\s*(node\s*=)?\s*(-?\w+)\s*,\s*(ofsection\s*=)?\s*(-?\w+)\s*,\s*(immediate\s*=)?\s*(-?\w+)\s*\)\s*(#\s*(-?\w+)\s*)?/i)){ //branchto(node=1899, ofsection=-1, immediate=false) #1
      action.track = gettrack(m[8]);
      action.type = PATHACTIONTYPE.PATHACTION_BRANCHTO;
      action.act.branch={};
      action.leftvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
      action.act.branch.node = parseInt(m[2]);
      action.act.branch.ofsection = parseInt(m[4]);
      action.act.branch.immediate = eval(m[6])?'-1':'0';
      if(action.act.branch.node==-1 && action.act.branch.ofsection==-1 && action.act.branch.immediate==-1){
        action.rightvaluetype = PATHVALUETYPE.PATH_VALUE_INTEGER;
      }else{
        action.rightvaluetype = 0;
      }
    }else{
      console.log('unknown action line: ', astr);
      return null;
    }
    return action;
  }
  for(var i=0;i<lines.length;i++){
    if(!varset) {
      var m = lines[i].match(/\s*vars\s*:\s*\{\s*/); //vars: {
      if(m){
        varbegin = true;
        continue;
      }
    }
    if(varbegin){
      var m = lines[i].match(/\s*}\s*,\s*/); // },
      if(m){
        varbegin = false;
        varset = true;
        continue;
      }
      m = lines[i].match(/\s*(\w+)\s*:\s*([0-9][0-9]*)\s*,\s*/i); // player: 0,
      if(m){
        namedvars.push({name:m[1], value:eval(m[2])});
        continue;
      }
    }
    if(!eventbegin){
      var m = lines[i].match(/\s*event\s*:\s*\{\s*/i); // event: {
      if(m){
        eventbegin = true;
        currentevent = {actions:[],numactions:0};
        actions.push(currentevent.actions);
        events.push(currentevent);
        eventoffsets.push(Math.round(eventoffset));//round it just in case
        eventoffset += eventsize/4;
        continue;
      }
    }else{
      if(!actionbegin&&!currentevent.eventID){
        var m = lines[i].match(/\s*eventID\s*:\s*(\w+)\s*,\s*/i); // eventID: PATH_EVENT_SetPlayerAllied_0xd9047,
        if(m){
          currentevent.eventID = eid(m[1]);
          continue;
        }
      }
      if(!actionbegin){
        var m = lines[i].match(/\s*actions\s*:\s*\[\s*/i); // 	actions:[
        if(m){
          actionbegin = true;
          continue;
        }
      }else{
        var m = lines[i].match(/\s*]\s*,\s*/); // ],
        if(m){
          actionbegin = false;
          continue;
        }else{
          var action = parseaction(lines[i]);
          if(action){
            currentevent.actions.push(action);
            currentevent.numactions++;
            eventoffset += actionsize/4;
            ac++;
          }
        }
      }
      m = lines[i].match(/\s*}\s*,\s*/); // },
      if(m){
        eventbegin = false;
        //just in-case
        actionbegin = false;
        continue;
      }
    }
  }
  //console.log(events, actions, eventoffsets);

  /*
  header
  nodeoffsets
  nodes, branches 
  eventoffsets 
  events,actions
  namedvars
  noderouters 
  trackoffsets 
  trackinfos
  sampleoffsets 
  */

  newmpfobj.header.numevents = events.length;
  newmpfobj.events = events;
  newmpfobj.actions = actions;
  newmpfobj.eventoffsets = eventoffsets;
  newmpfobj.header.numnamedvars = namedvars.length;
  newmpfobj.namedvars = namedvars
  newmpfobj.header._eventdatasize = eventoffset*4;
}
    </script>
  </body>
</html>
